---
title: 09.Error (-701)-(-800)
description: 
published: true
date: 2023-02-26T12:33:41.152Z
tags: 
editor: markdown
dateCreated: 2023-02-26T12:23:47.470Z
---

-702	Cannot open database in exclusive mode.

Within an X/Open distributed transaction processing environment, you
cannot open a database in exclusive mode.


-703	Primary key on table table-name has a field with a null key value.

An attempt was made either to insert a null value into a column that is
part of a primary key, or to add a primary constraint to a table that
has a NULL value in one of the key columns.


-704	Primary key already exists on the table.

A table can have only one primary key.


-705	Cannot drop/modify procedure procedure-name. It is currently in use.
 
An attempt was made either to drop a currently executing procedure or
to run UPDATE STATISTICS on a currently running procedure. This
condition can occur if a procedure tries to drop itself or if a nested
procedure tries to drop a procedure that called it.

Example of error:

   CREATE PROCEDURE testproc()
   ...
   DROP PROCEDURE testproc; -- error 
   END PROCEDURE

Correction: You can use an ON EXCEPTION statement to trap this error
and not carry out the DROP PROCEDURE or UPDATE STATISTICS statement.

This error also occurs if you try to drop a function or procedure
that a functional index is using.

This error also occurs if you try to drop a function or procedure
that a xadatasource type is using.

-706	Execute privilege denied on procedure procedure-name.

A user who does not own the procedure or is not DBA must have Execute
privilege in order to run a procedure.


-707	TEXT and BYTE columns in optical cluster must be distinct.

The same column is specified more than once in the column list of the
FOR clause in the CREATE OPTICAL CLUSTER statement. Change your
statement so that no column appears more than once.


-708	Optical cluster cluster-name already exists.

You have attempted to create a new optical cluster with the name of an
existing cluster. You must either drop the existing cluster or
re-execute your statement using a different cluster name.


-709	TEXT and BYTE column column-name is already clustered.

You have already created an optical cluster using the named column.
Because a single column can be part of only one optical cluster, your
attempt to create a new cluster on this column has failed.


-710	Table <table-name> has been dropped, altered, or renamed.

This error can occur with explicitly prepared statements. These statements
have the following form:

    PREPARE statement id FROM "quoted_string"

After a statement has been prepared in the database server and before
execution of the statement, a table to which the statement refers might have
been renamed or altered, possibly changing the structure of the table.
Problems might occur as a result. Adding an index to the table or
altering the fragmentation scheme after preparing the statement can also
invalidate the statement.

This error can also occur with SPL routines. Before the database server
executes a new SPL routine the first time, it optimizes the code
(statements) in the SPL routine. Optimization makes the code depend on
the structure of the tables that the procedure references. If the table
structure changes after the procedure is optimized, but before it is
executed, this error can occur.

The Auto Re-prepare feature allows the database server to check prepared 
statements and stored procedures prior to execution for changes to any tables
that they reference. This feature prevents many of the common causes for the
-710 error.

When the Auto Re-prepare feature is enabled the following semantics apply:

Before execution of a prepared statement or SPL routine the database server
checks to determine if the structure of directly or indirectly referenced
tables may have changed. If changes are detected the statement is checked
prior to re-prepare:

    * A change in the number or type of columns in the SELECT list will result
      in error -710 being raised. In this case the application should prepare
      and execute the statement again to allow the database server to 
      re-describe the SELECT list.

    * For other changes the database server automatically re-prepares the
      statement. If this is successful the statement will then be executed.

Stored procedures are re-optimized and executed if the reoptimization succeeds.

An error that occurs during the re-prepare of a statement or re-optimization of
a SPL routine is returned to the application in place of the -710 error.

When the Auto Re-pepare feature is not enabled the following semantics apply:

A subsequent OPEN command for a cursor will fail if the cursor refers to the
invalid prepared statement; the failure will occur even if the OPEN command has
the WITH REOPTIMIZATION clause.

If an index was added or the fragmentation scheme was altered after the
statement was prepared, you must prepare the statement again and declare
the cursor again. You cannot simply reopen the cursor if it was based on a
prepared statement that is no longer valid.

This error can also occur if the table referenced by the statement has 
any foreign key references to tables that were renamed after the statement
was prepared.

Each SPL routine is optimized the first time that it is run (not when
it is created). This behavior means that an SPL routine might succeed
the first time it is run but fail later under virtually identical
circumstances. The failure of an SPL routine can also be intermittent
because failure during one execution forces an internal warning to
reoptimize the procedure before the next execution.
 
The database server keeps a list of tables that the SPL routine
references explicitly. Whenever any of these explicitly referenced tables is
modified, the database server reoptimizes the procedure the next time the
procedure is executed.

However, if the SPL routine depends on a table that is referenced only
indirectly, the database server cannot detect the need to reoptimize the
procedure after that table is changed. For example, a table can be
referenced indirectly if the SPL routine invokes a trigger. If a table
that is referenced by the trigger (but not directly by the SPL routine)
is changed, the database server does not know that it should reoptimize the
SPL routine before running it. When the procedure is run after the
table has been changed, this error can occur.

Use one of two methods to recover from this error:

    *   Issue the UPDATE STATISTICS statement to force reoptimization of the
        procedure.

    *   Rerun the procedure.

To prevent this error, you can force reoptimization of the SPL routine.
To force reoptimization, execute the following statement:

    UPDATE STATISTICS FOR PROCEDURE procedure_name

You can add this statement to your program in either of the following ways:

    *   Place the UPDATE STATISTICS statement after each statement that
        changes the mode of an object.

    *   Place the UPDATE STATISTICS statement before each execution of the
        SPL routine.

For efficiency, you can put the UPDATE STATISTICS statement with the action
that occurs less frequently in the program (change of object mode or
execution of the procedure). In most cases, the action that occurs less
frequently in the program is the change of object mode.

When you follow this method of recovering from this error, you must execute
the UPDATE STATISTICS statement for each procedure that references the 
changed tables indirectly unless the procedure also references the tables
explicitly.

You can also recover from this error by simply rerunning the SPL routine.
The first time that the stored procedure fails, the database server
marks the procedure as in need of reoptimization. The next time that
you run the procedure, the database server reoptimizes the procedure before
running it. However, running the SPL routine twice might be neither
practical nor safe. A safer choice is to use the UPDATE STATISTICS statement
to force reoptimization of the procedure.

-711	Cannot insert encoded BLOB descriptor.

An attempt to insert an encoded blob descriptor by means of the DESCR()
function has failed. See the ISAM error for more information.


-712	Cannot insert encoded BLOB descriptor in non-optical BLOB columns.

You have attempted to use the DESCR() function to insert an encoded
blob descriptor into a TEXT or BYTE column that is stored in a dbspace
or blobspace. You can use this function only to insert descriptors into
blob columns that are stored on optical media.


-713	Cannot decode encoded BLOB descriptor.

The decoding of a blob descriptor prior to its insertion into a data
row has failed. See the error from the optical subsystem (an error in
the -7000 to -7199 range) for more information.


-714	Cannot encode BLOB descriptor.

The encoding of a blob descriptor for storage on optical media has
failed. See the error from the optical subsystem (in the -7000 to -7199
range) for more information.


-715	Transaction state error.

An error occurred in retrieving a transaction state. See the ISAM error
for more information.


-716	Possible inconsistent transaction. Unknown servers are server-name-list.

This message appears after an administrator ends a coordinator
database server process, thread, or session using tbmode -z or onmode
-z any time after the coordinator issues its decision either to commit
or roll back a two-phase commit transaction. You must examine the
message log or the logical log at each of the database servers for
which the status is listed as unknown to determine whether the local
transaction was committed or rolled back. If some participating
database servers rolled back the transaction, and others committed it,
you must determine whether your networked database system is in an
inconsistent state. This procedure is described in detail in your
Administrator's Guide.


-717	Invalid argument passed to system function function-name.

An invalid data type has been passed to one of the arithmetic functions
(HEX(), TRUNC(), ROUND()).


-718	Statement is invalid while a global transaction is suspended.

If a database server that is acting as a Resource Manager in an X/Open
distributed transaction-processing environment has suspended a
transaction, its next statement must be xa_start. All other statements
are disallowed.


-719	Loop variable variable-name cannot be declared GLOBAL.

A global variable cannot be used as a loop variable. Redefine the
variable to be local to the loop, or use another (local) variable as
the loop variable.


-720	The number of returned values and of SPL variables do not match.

The list of SPL variables that follows the INTO keyword has a different 
cardinality from the number of values in each row of the active set.  
This error can occur during the FOREACH statement of SPL, or during the 
FETCH statement of dynamic SQL. 

In a FOREACH statement with an embedded SELECT statement, the variable 
list that follows the INTO keyword in the SELECT statement does not match 
the number of columns or expressions in each row that the SELECT statement 
retrieves.  In a FOREACH statement with an embedded EXECUTE FUNCTION or 
EXECUTE PROCEDURE statement, the INTO clause that follows the routine 
argument list specifies a list of variables whose number does not match 
the number of values that the routine returns.   

In a FETCH statement, the variable list that follows the INTO keyword does 
not match the number of columns or expressions in each row that a SELECT 
statement retrieves, or does not match the number of values returned by a 
function call. A DECLARE statement in the same SPL routine associated the 
cursor that FETCH specifies with a SELECT statement or with an 
EXECUTE FUNCTION or EXECUTE PROCEDURE statement.  

For example, the following dynamic SQL statements inside a procedure body 
returns this error when the procedure is executed, because fetching from 
the cursor returns two values (c1, c2) but has only one local variable 
(l_out1) to receive those two column values:

   create procedure proc()
   define qry_str varchar(120);
   define l_out1  char(10);

      let qry_str = "select c1,c2 from t1";

      prepare stmt_id from qry_str;

      declare my_cur cursor for stmt_id;

      open my_cur;

      fetch my_cur into l_out1;

      ....
   end procedure; 

To avoid this error, review the logic of the FOREACH or FETCH statement to 
verify that the list of variables in the INTO clause matches the number of 
values in the projection list of the SELECT statement, or matches the number 
of values returned by the routine. Both FOREACH and FETCH require a 1-to-1 
correspondence in number, order, and data type between the list of SPL 
variables in the INTO clause and the values returned by a call or in each 
row returned by a query.

If more than one cursor is open when a FETCH statement receives this error, 
make sure that the FETCH statement references the correct cursor.


-721	SPL routine (<routine-name>) is no longer valid.

You are attempting to execute a procedure from an EXECUTE statement,
but it has been redefined since the PREPARE statement was run. You must
use the PREPARE statement again on the EXECUTE PROCEDURE statement.

For example, the following sequence of code would cause this error:

$prepare pr_stat from 'execute procedure testproc()';
	...
	/* drop procedure testproc create procedure testproc() ......
	[same application or different] */
	...
	$execute pr_stat;/* triggers error -721 */


-722	Out of stack space.

The database server has run out of memory for stack space. Ask the
GBase database administrator to increase the STACKSIZE parameter
that is specified in the $ONCONFIG file to allocate more memory. The 
database server must be restarted for the change to take effect.


-723	Cannot disable logging in an ANSI-compliant database.

You attempted to use the START DATABASE <database> WITH NO LOG syntax
to remove database logging on an SE database that is ANSI compliant.
You cannot turn off logging by running this statement on this kind of
database.


-724	System initialization file $GBASEDBTDIR/cnv50t60.sql is missing.

Check that $GBASEDBTDIR/cnv50t60.sql is in place and readable. If it
is, and the system still fails, reinstall the system.


-725	Error occurred while reading system initialization file
$GBASEDBTDIR/cnv50t60.sql.

Check that the script file $GBASEDBTDIR/cnv50t60.sql is readable. If it
is, and the failure still occurs, reinstall the product.


-726	First argument to dbinfo() must be a quoted string constant.

The first argument to dbinfo() should be a quoted string constant. If
the first argument to dbinfo() is the string 'version', then the second
argument should also be a quoted string constant.


-726	First argument to dbinfo() must be a quoted string constant.

Check that the first argument to dbinfo() is a quoted string that
corresponds to one of the following values: 'dbspace', 'sqlca.sqlerrd1',
or 'sqlca.sqlerrd2'.


-727	Invalid or NULL tblspace number given to dbinfo(dbspace).

You called the dbinfo() function with the 'dbspace' string constant as
the first parameter. You must provide either the number of a valid
tablespace or an expression that evaluates to such a number as the
second parameter. Check that you supplied a number as your second
parameter and that it corresponds to the number of a valid tablespace.


-728	Unknown first argument of dbinfo(<argument>).

Check that the first argument to dbinfo() is a quoted string that corresponds
to one of the following values: 'dbspace', 'version', 'sqlca.sqlerrd1',
'sqlca.sqlerrd2', 'sessionid', 'coserverid', 'utc_to_datetime',
'utc_current', 'get_tz', or 'dbhostname'.


-728	Unknown first argument of dbinfo argument-name.

The valid arguments to the dbinfo() function are the quoted string
'dbspace' followed by the number of a valid tablespace, or one of the
following two values: 'sqlca.sqlerrd1' or 'sqlca.sqlerrd2'. Check that
you supplied one of these values and enclosed the string in quotes.


-729	Trigger has no triggered action.

Your CREATE TRIGGER statement does not include a triggered action. Add
a triggered action list to the trigger definition, and resubmit the
CREATE TRIGGER statement.


-730	Cannot specify REFERENCING if trigger does not have FOR EACH ROW.

You included a REFERENCING clause in a CREATE TRIGGER statement that
does not include a FOR EACH ROW triggered-action section. Either remove
the REFERENCING clause or, if it is appropriate, add the missing
keywords FOR EACH ROW, followed by the triggered actions that are to
occur at that time.


-731	Invalid use of column reference in trigger body.

For insert and delete triggers, the offending column is being used in
the INTO clause of the EXECUTE PROCEDURE statement (which is only
allowed for an update trigger). Remove the column names from the INTO
clause.


-732	Incorrect use of old or new values correlation name inside trigger.

You cannot use the new or old correlation name outside the FOR EACH ROW
section or in the INTO clause of the EXECUTE PROCEDURE statement. You
cannot use the new or old correlation name to qualify the SELECT COUNT
DISTINCT column. For example, the following statement returns this
error:

SELECT COUNT (DISTINCT oldname.colname)

You cannot specify an old correlation name for an insert trigger. You
cannot specify a new correlation name for a delete trigger.


-733	Cannot reference procedure variable in CREATE TRIGGER or CREATE VIEW
statement.

You have a CREATE TRIGGER or CREATE VIEW statement inside an SPL
routine, and within the CREATE TRIGGER or CREATE VIEW statement,
you reference a variable that is defined in the SPL routine.
This action is not legal. Remove the reference to the SPL-routine
variable from the CREATE TRIGGER or CREATE VIEW statement and try again.


-734	Object name matches old or new values correlation name.

This error is returned in three cases:

    *   The name of the triggering table or the synonym, if it is used,
	matches the old or new correlation name in the REFERENCING
	clause.

    *   The name of a table or a synonym that is referenced in the
	action clause matches either the old or new correlation name in
	the REFERENCING clause.

    *   The old correlation name matches the new correlation name.

Change either the correlation name or the table name, and execute the
CREATE TRIGGER statement again.


-735	Cannot reference table that participates in cascaded delete.

The child table is either referenced in a correlated subquery that is part of
a DELETE or MERGE statement or as a source table in a MERGE statement. The 
child table cannot be one of the tables on which a delete would cascade. 
These actions are not allowed because the result depends on the order in which 
the rows are processed. Rewrite your query so that the child table is not 
referenced in a correlated subquery, or as source table of the MERGE statement,
or both.


-736	The RESOLUTION and SAMPLING SIZE clauses are not valid for the 
LOW mode of the UPDATE STATISTICS statement.

Because data distributions are constructed only in the MEDIUM or HIGH
modes of the UPDATE STATISTICS statement, specifying the resolution or 
sampling size is not meaningful in LOW mode. 

Remove the RESOLUTION clause and the SAMPLING SIZE clause from the statement.

To use the SAMPLING SIZE clause, change the mode to MEDIUM. To use the 
RESOLUTION clause, change the mode to MEDIUM or HIGH.


-737	The confidence value and the SAMPLING SIZE clause are not valid for the 
HIGH mode of the UPDATE STATISTICS statement.

Remove the confidence value and the SAMPLING SIZE clause from the statement. 

For example, the following statement has a confidence value of 0.99:

UPDATE STATISTICS HIGH RESOLUTION 0.1 0.99;

The corrected statement is:

UPDATE STATISTICS HIGH RESOLUTION 0.1;

If you want a distribution that is based upon sampling rather than one
that uses all of the data in a column, change the mode from HIGH to MEDIUM 
and you specify number of samples using the SAMPLING SIZE clause.


-738	DROP DISTRIBUTIONS is only valid in LOW mode.

By default, LOW mode does not remove distributions, so you need to use
the DROP DISTRIBUTIONS clause. To remove HIGH or MEDIUM distributions,
use the DROP DISTRIBUTIONS clause.


-739	Confidence must be in the range [0.80, 0.99] (inclusive).

If the value of the confidence desired is greater than 0.99, use HIGH
mode. A value of less than 0.80 is not allowed because it will probably
yield a poor distribution. If you are reducing the confidence to reduce
the time that is required to execute the UPDATE STATISTICS statement,
consider using a larger resolution value.


-740	Resolution must be greater than 0.005 and less than, or equal to, 10.0.

The value of this parameter determines how finely the data distribution
is resolved. A resolution of 10.0 implies that the accuracy of any
estimate for the application of any single selection filter is limited
to (+ or -) 5 percent. A value greater than 10.0 would be of little
value because it would not provide sufficient detail about the
distribution of the data.


-741	Trigger for the same event already exists.

You are creating a trigger for an event, but another trigger already
exists for that event. You can have only one insert or delete trigger
on a table. If you are defining multiple triggers that occur on an
update, the column lists in the UPDATE statements must be mutually
exclusive. You cannot name a column as a triggering column in more than
one UPDATE clause.


-742	Trigger and cascading-delete referential constraint cannot coexist.

Delete triggers cannot coexist with referential constraints.

This error occurs if you try to add a delete cascade foreign key to a table 
that already has a delete trigger on it. This error also occurs if you try
to add a delete trigger to a table that already has a delete cascade foreign
key.


-743	Object object_name already exists in database.

You are trying to define an object that already exists in the database.


-744	Illegal SQL statement in trigger.

This error is returned when the triggered SQL statement is BEGIN WORK,
COMMIT WORK, ROLLBACK WORK, or SET CONSTRAINTS. These statements are
not allowed as triggered actions. Remove the offending statement.


-745	Trigger execution has failed.

This message is defined for general use to apply to error conditions
that you specify in an SPL routine that is a triggered action.


-746	message-string

You supply message-string for this message. You can apply this message 
to error conditions that you specify in an SPL routine. The corrective
action for this error depends on the condition that caused it. You, the user,
define both the condition and the message text.


-747	Table or column matches object referenced in triggering statement.

This error is returned when a triggered SQL statement acts on the
triggering table, or when both statements are updates, and the column
that is updated in the triggered action is the same as the column that
the triggering statement updates.


-748	Exceeded limit on maximum number of cascaded triggers.

You exceeded the maximum number of cascading triggers, which is 61. You
may be setting off triggers without realizing it. You can query the
systriggers system catalog table to find out what triggers exist in the
database. To trace the triggered actions, place the action clause of
the initial trigger in an SPL routine, and use the SPL TRACE
statement.


-749	Remote cursor operation disallowed with pre-5.01 server.

An external database server before Version 5.01 sent the triggering
statement or cursor operation. This action is not allowed.


-750	Invalid distribution format found for table_name.

This internal error should not occur unless the database has been
corrupted in some way. To rebuild the distribution, use UPDATE
STATISTICS. If the error recurs, note all circumstances and
contact GBase Technical Support.


-751	Remote procedure execution disallowed with pre-5.01 server.

The action clause of the trigger contains an SPL routine that is
not called in a data manipulation statement, and an external database
server before Version 5.01 will execute the procedure. This action is
not allowed. An SPL routine that is called within a data
manipulation statement cannot execute certain SQL statements, including
transaction-related statements. Transaction-related statements are not
allowed within an SPL routine that is a triggered action. A database
server before Version 5.01 cannot check for this condition, so
the procedure is not allowed. If possible, execute the procedure on a
Version 5.01 or later database server.


-752	All Smart Disk devices are busy.

Wait a while and retry your Smart Disk operation.


-753	Access denied - Single user limit has been exceeded.

Licensing enforcement is configured for only one user; multiple users
cannot use the product at the same time. If you are using the product
from a remote computer, the product is licensed only for a nonnetworked
environment.If you are using the product from a local computer, wait
until the current user exits and try again.


-754	Cannot access the license file.

The system cannot find the user license file. The user license file
might not have been installed, or it might have been installed
improperly. Also, you might not have the correct file or directory
permissions to access the user license file. Consult your installation
documentation.


-755	Cannot access the license file to release license.

You might not have appropriate permission for your particular action.
Check with your system administrator.


-756	Evaluation version has expired.

The evaluation version of this product will work only for a specified
period of time. This version allows you to evaluate the product but not
use it permanently. When the evaluation version expires, call GBase
to order a standard version of the product.


-757	File open for light append can't pseudo close.

If this internal error recurs, note all circumstances and
contact GBase Technical Support.


-758	Cannot implicitly reconnect to the new server server_name.

If you use the CONNECT TO statement to connect to a server, you cannot
implicitly reconnect to another server through one of the DATABASE
statements (DATABASE, START DATABASE, and so on). You must switch to it
with the SET CONNECTION statement.


-759	Cannot use database commands in an explicit database connection.

If you use the CONNECT TO database@server syntax to connect to a database
and server, you cannot select another database until you disconnect your
current connection.


-760	Remote procedure must commit or rollback before returning.

Your remote procedure must execute a COMMIT WORK or ROLLBACK WORK
statement before that procedure returns control to your application.


-761	GBASEDBTSERVER does not match either DBSERVERNAME or DBSERVERALIASES.

Your GBASEDBTSERVER environment variable does not match the
DBSERVERNAME or any of the DBSERVERALIASES settings in the ONCONFIG
configuration file of the server to which you are trying to connect.
Check your environment variables and the ONCONFIG configuration file.
Check that GBASEDBTSERVER matches one of the settings in the ONCONFIG
file.


-762	Stack overflow occurred during statement parse.

This error indicates that an internal memory limitation in the SQL
parser has been reached. This condition can occur if your query
contains many nested expressions. For example, the query might contain
many occurrences of AND and/or OR in the WHERE clause. To work around
this condition, rewrite the query to eliminate some of the nested
expressions.


-763	Error in auditing environment initialization.

This all-purpose message indicates a problem when a user tries to
connect to a secure database server. Contact your security
administrator or DBA for how to proceed.


-764	Only DBA can run update statistics on a database in this mode.

You tried to run the UPDATE STATISTICS statement with the DROP
DISTRIBUTIONS clause on the entire database in a mode other than LOW.
Only user gbasedbt or the database administrator can do perform this
action.


-765	Cannot EXECUTE a statement that has been DECLAREd.

You cannot execute a prepared statement that has been declared.
However, to specify output variables for a prepared singleton SELECT
statement, use EXECUTE INTO (or EXECUTE PROCEDURE INTO) instead of
executing DECLARE, OPEN, and FETCH statements.


-766	String must be null terminated.

With GBase ESQL/C, if you use a host variable in an INSERT statement
or in the WHERE clause of an SQL statement, and the database is ANSI
compliant, the string must be null terminated.


-767	Cannot UPDATE/INSERT a remote table using views with check options.

You cannot perform an UPDATE or INSERT operation on a table that
resides across a network when you are using views that have check
options. Remove the all check options from the view, or perform the
UPDATE/INSERT locally.


-768	Internal error in routine routine-name.

If this internal error recurs, note all circumstances and
contact GBase Technical Support.


-769	Internal - iterator execution/phase error parameter.

If you cannot find a direct cause for this internal error, note
all circumstances and contact GBase Technical Support.


-770	Bad fragment id specified.

If you cannot find a direct cause for this internal error, note
all circumstances and contact GBase Technical Support.


-771	Bad table lock id specified.

If you cannot find a direct cause for this internal error, note
all circumstances and contact GBase Technical Support.


-772	Record/key doesn't qualify for any table/index fragment.

This error can occur during a record insert or update. The most likely
cause is an incorrect fragmentation specification that did not specify
a REMAINDER. The easiest correction is to add a REMAINDER fragment to
your SQL statement. However, the best correction is probably to
reexamine the original fragmentation specification, figure out what is
wrong, and fix it with an ALTER FRAGMENT statement.

For interval fragmented table or index, ensure that automatic interval
fragment creation is enabled. The following query can be used to determine if
automatic interval fragment creation is enabled for a table and its indexes:

    SELECT t.tabname, f.indexname,
	   decode(bitand(f.flags, 2048), 0, 1, 0) intvl_enabled
        FROM sysfragments f, systables t
        WHERE f.tabid = t.tabid AND
              f.evalpos = -2 AND
              t.tabname = <tabname>;

The following are examples on how to enable automatic interval fragment
creation for an interval fragmented table or index:

    ALTER FRAGMENT ON TABLE <tabname> MODIFY INTERVAL ENABLED;
    ALTER FRAGMENT ON INDEX <idxname> MODIFY INTERVAL ENABLED;


-773	Expression required for new fragment.

When you add a fragment to an expression-based fragmentation strategy,
you must specify an expression for the new fragment. Restate your SQL
statement to include a fragment expression.


-774	Cannot specify fragment expressions with a round-robin fragmentation.

If table fragmentation is based on a round-robin strategy, you cannot
specify a fragment expression during an ALTER FRAGMENT operation.


-775	Fragment partition name not used by table/index.

The partition that is specified during an ALTER FRAGMENT operation is
incorrect because that partition contains no fragment. 
Specify a partition that has a fragment. Partition names default to the
dbspace name if not specified at create time.


-776	Alter fragment error: unable to move rows to new fragmentation scheme.

During an ALTER FRAGMENT operation, the rows could not be moved to
another fragmentation strategy. See the accompanying ISAM error for
more information on why the ALTER FRAGMENT operation failed.


-777	Internal - function not valid on fragmented table.

If you cannot find a direct cause for this internal error, note
all circumstances and contact GBase Technical Support.


-778	Unable to alter fragmentation scheme on index or table.

During an ALTER FRAGMENT operation, the fragmentation strategy for the
index or table could not be altered. See the accompanying ISAM error for more
information on why the ALTER FRAGMENT operation failed.


-779	Duplicate table name in the alter fragment specification.

You cannot attach the same table multiple times. Check that your alter
fragment specification attaches the same table only once.


-780	Table/index is not fragmented.

You cannot perform the ALTER FRAGMENT operation because the table or
index is not fragmented. Fragment the table or index, or do not perform
the fragmentation operation.


-781	Cannot alter fragmentation on a temp table.

You tried to alter a fragment that is based on a temporary table. In
general, dynamic modification of a TEMP table is not allowed. You must
re-create the temporary table if you require a different fragmentation
scheme.


-782	Attached table is fragmented.

When you attach tables, the consumed table cannot be fragmented.


-783	Cannot attach because of incompatible schema.

Incompatible table schemas do not allow you to perform an attach. When
you perform an attach, the table schemas must be identical and tables must
be compatiable from LBAC perspective. Use the ALTER TABLE statement to 
make the schemas identical, the surviving table and consumed table
to be protected by the same security policy, and make the protected 
columns to be protected by the same set of security labels. Then perform 
an ALTER FRAGMENT...ATTACH operation.


-784	Cannot detach because of the existing referential constraints.

Existing referential constraints do not allow you to perform a detach.
You must drop the referential constraints before you perform the detach
on the dbspace/partition or table.


-785	Cannot drop column because of table or index fragmentation.

You must alter fragmentation expressions to remove references to the
column before the column can be dropped.


-786	Cannot attach to this table because it is not in the list of tables in the ATTACH clause.
 
The surviving table is either nonfragmented or hash-fragmented and must
appear in the attach list in order for its existing fragment to be 
properly positioned in the resulting fragmentation scheme.


-787	Index fragmented same-as-table cannot be altered.

If you do not specify storage-spec in a CREATE INDEX statement, the
indexes are fragmented the same as the underlying table, subject to all
the restrictions on fragmented indexes. For example, an error is
returned if the underlying fragmentation strategy is round-robin, and
the index is unique. You cannot alter this type of index fragmentation.
If you want to change the index fragmentation, use the INIT option of
ALTER INDEX to detach the index. That operation makes the index and
table independent and lets you alter each independently.


-788	Unknown operator/type.

If you cannot find a direct cause for this internal error, note
all circumstances and contact GBase Technical Support.


-789	Internal error, expression not properly defined.

If you cannot find a direct cause for this internal error, note
all circumstances and contact GBase Technical Support.


-790	Cannot create interval fragment.

An error occurred while creating an interval fragment. Retry the operation
after some delay. If the error persists, note all circumstances and contact
GBase Technical Support.


-791	Cannot find fragment for the row.

An error occurred while finding a fragment for the row. For an
interval fragmented table or index, a failure occurred while evaluating
the fragment position for the row.

Examine the data value in the row with the definition of your
fragmentation strategy to verify that the row can be stored in one of
the initial range fragments or the interval fragments.


-792	Cannot update the sysfragments system catalog table for an interval fragment.

An error occurred while updating the sysfragments system catalog table for the
newly created interval fragment. Insufficient disk space is a common cause of
this error.


-793	Page size of the dbspace does not match page size of the table or index.

The page size of the dbspace does not match page size of the table or index.
All fragments of a table or index must be created in dbspace of same page
size. If this is an interval fragmented table or index, ensure that all
dbspaces in the STORE IN clause have same page size and match the page 
size of the initial fragment dbspaces.


-794	One or more dbspaces for interval fragments do not exist.

One or more dbspaces in the STORE IN clause of an interval fragmented table
or index do not exist. Contact the database server administrator to
have the dbspaces added. Alternatively you can use the ALTER FRAGMENT 
statement for the table or index to modify the STORE IN clause to list
dbspaces that exist in the system. Always ensure that the page size of the
dbspace matches the page size of the table or index.


-795	One or more dbspaces for interval fragments are unusable.

The primary chunk (and the mirror chunk, if one exists) for one or more
dbspaces in the STORE IN clause of an interval fragmented table or index are
unusable. Roll back the current transaction and terminate the application.
Contact the database server administrator to repair the dbspaces.


-796	Fragment position for the row exceeds the maximum allowed.

The fragment position for the row exceeds 2147483646. Consider changing
the interval value expression or transition value to accommodate the row.


-797	Fragment is not empty.

The fragment contains data rows or index items and is not empty.


-798	No permission on table to create an interval fragment.

The user does not have the required table-level privilege to create an interval
fragment. An interval fragment can be created during an INSERT or an UPDATE
operation. If an INSERT operation triggers the creation of an interval
fragment, then user must have INSERT privilege at the table-level. Similarly,
if an UPDATE operation triggers the creation of an interval fragment, then user
must have UPDATE privilege at the table-level.


-800	Corresponding data types must be compatible in CASE expression or DECODE function.

All the result values in all the WHEN clauses in the CASE expression should be
of compatible data types. In the linearized use of the CASE expression, the
value-expression that follows the CASE keyword should be compatible with the
value-expressions that follow all the WHEN keywords in the CASE expression.
Reissue the query after modifying the CASE expression so that all
related expressions are of compatible data types.

This error can also occur when the expressions for the DECODE function do not
have compatible data types. The DECODE function has four possible expressions:
expr, when_expr, then_expr, and else_expr. All instances of when_expr must have
the same or a compatible data type as expr.  All instances of then_expr must
have the same or a compatible data type as else_expr. Reissue the query after
modifying the DECODE function so that all related expressions are of same or
compatible data types.

This error can also occur when calling functions that use implicit casts
and comparisons between data types, such as the NVL function. In this case,
revise your program logic (for example, by adding an explicit cast). so that
the expressions return the same or compatible data types.